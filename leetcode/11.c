给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/container-with-most-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

//这道题目的最优解法是双指针,时间复杂度O(n)
//难点在于如何证明双指针的思路是对的
//我先把双指针的思路简单阐述
//再去证明其正确性
//
//首先我们定义首尾两个指针
//计算其面积
//为了得到更大的面积，根据我们朴素的直观感受
//我们需要把短的那根柱子舍弃掉
//然后再计算面积
//每次取较大的面积
//直到最后即可得到最大的面积
//
//
//下面证明双指针做法的正确性
//首先在最开始的时候，我们指定了两端的两个柱子
//在我们计算面积之后
//如果选择固定一根柱子，另一根变化，水的面积会有什么变化？
//
//--如果固定短的那根柱子
//----由于水的高度由短的柱子的高度决定
//--------由于移动，必然使得(j-i)减小
//----如果新柱子较高，那么由于(j-i)减小，所以面积减小
//----如果新柱子较短，面积也必然会减小
//--因此，如果固定短的柱子，无论另一根柱子如何移动变化，都会使得面积减小
//也就是说，固定短的，移动另一个，水的高度一定不会增加，且宽度一定减小
//由此也就排除掉了短柱子和其他任何一个柱子的组合
//
//--如果我们固定高的柱子 移动短的柱子的话
//----那么就有可能换到一个更高的水面高度
//
//因此，我们不能排除长柱子和其他任何一个柱子的组合
//
//随着不断的排除，i和j都会往中间移动
//当i和j相遇，算法就结束了

int maxArea(int* height, int heightSize){
    int i=0,j=heightSize-1;
    int sum=0,duff;
    int high;
    while(i<j)
    {
        if(height[i]>height[j])
        {
            high = height[j];
            duff = (j-i)*high;
            sum = (sum>duff) ? sum : duff;
            j--;
            continue;
        }
        else
        {
            high = height[i];
            duff = (j-i)*high;
            sum = (sum>duff) ? sum : duff;
            i++;
            continue;
        }
    }
    return sum;
}
